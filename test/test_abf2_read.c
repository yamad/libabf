#include <stdlib.h>
#include "unity.h"

#include "abf2_read.h"
#include "deserialize.h"
#include "swap.h"

void setUp(void) {}
void tearDown(void) {}

void test_abf2_get_block_offset(void)
{
    uint32_t block_index = 1;
    size_t result = abf2_get_block_offset(block_index);
    TEST_ASSERT_EQUAL_UINT(ABF2_BLOCKSIZE, result);
}

void test_abf2_section_block_offset(void)
{
    struct abf2_section test_sec = {
        .uBlockIndex = 1,
        .uBytes = 512,
        .llNumEntries = 1
    };
    TEST_ASSERT_EQUAL_UINT(ABF2_BLOCKSIZE, abf2_section_block_offset(&test_sec));
}

void test_abf2_needs_swap_littleendian(void)
{
    uint8_t bytes[4] = { 0x41, 0x42, 0x46, 0x32 };
    uint8_t *buf = bytes;
    int swap = abf2_needs_swap(buf);
    if (ENDIAN_LITTLE == get_endian()) {
        TEST_ASSERT_EQUAL_INT(0, swap);
    } else {
        TEST_ASSERT_EQUAL_INT(1, swap);
    }
}

void test_abf2_needs_swap_bigendian(void)
{
    uint8_t bytes[4] = { 0x32, 0x46, 0x42, 0x41 };
    uint8_t *buf = bytes;
    int swap = abf2_needs_swap(buf);
    if (ENDIAN_LITTLE == get_endian()) {
        TEST_ASSERT_EQUAL_INT(1, swap);
    } else {
        TEST_ASSERT_EQUAL_INT(0, swap);
    }
}

void test_abf2_can_open_tests_for_littleendian_ABF2_filesig(void)
{
    uint8_t bytes[4] = { 0x41, 0x42, 0x46, 0x32 };
    uint8_t *buf = bytes;
    int is_abf2_file = abf2_can_open(buf);
    TEST_ASSERT_EQUAL_INT(1, is_abf2_file);
}

void test_abf2_can_open_tests_for_bigendian_ABF2_filesig(void)
{
    uint8_t bytes[4] = { 0x32, 0x46, 0x42, 0x41 };
    uint8_t *buf = bytes;
    int is_abf2_file = abf2_can_open(buf);
    TEST_ASSERT_EQUAL_INT(1, is_abf2_file);
}

void test_abf2_can_open_fails_on_ABF1_filesig(void)
{
    uint8_t bytes[4] = { 0x20, 0x46, 0x42, 0x41 };
    uint8_t *buf = bytes;
    int is_abf2_file = abf2_can_open(buf);
    TEST_ASSERT_EQUAL_INT(0, is_abf2_file);
}

void test_abf2_read_section(void)
{
    uint8_t bytes[16] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                      0x08, 0X09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
    uint8_t *buf = bytes;
    bool to_swap = 0;

    struct abf2_section sec;
    abf2_read_sectionp(buf, &sec, to_swap);
    if (ENDIAN_LITTLE == get_endian()) {
        TEST_ASSERT_EQUAL_HEX32(0x03020100, sec.uBlockIndex);
        TEST_ASSERT_EQUAL_HEX32(0x07060504, sec.uBytes);
        TEST_ASSERT_EQUAL_HEX64(0x0F0E0D0C0B0A0908, sec.llNumEntries);
    } else {
        TEST_ASSERT_EQUAL_HEX32(0x00010203, sec.uBlockIndex);
        TEST_ASSERT_EQUAL_HEX32(0x04050607, sec.uBytes);
        TEST_ASSERT_EQUAL_HEX64(0x08090A0B0C0D0E0F, sec.llNumEntries);
    }
}

void test_abf2_read_section_swapped(void)
{
    uint8_t bytes[16] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                      0x08, 0X09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
    uint8_t *buf = bytes;
    bool to_swap = 1;

    uint8_t *head = buf;
    struct abf2_section sec;
    buf = abf2_read_sectionp(buf, &sec, to_swap);
    TEST_ASSERT_EQUAL_INT(16, (buf - head));
    if (ENDIAN_LITTLE == get_endian()) {
        TEST_ASSERT_EQUAL_HEX32(0x00010203, sec.uBlockIndex);
        TEST_ASSERT_EQUAL_HEX32(0x04050607, sec.uBytes);
        TEST_ASSERT_EQUAL_HEX64(0x08090A0B0C0D0E0F, sec.llNumEntries);
    } else {
        TEST_ASSERT_EQUAL_HEX32(0x03020100, sec.uBlockIndex);
        TEST_ASSERT_EQUAL_HEX32(0x07060504, sec.uBytes);
        TEST_ASSERT_EQUAL_HEX64(0x0F0E0D0C0B0A0908, sec.llNumEntries);
    }
}

void test_abf2_read_guid(void)
{
    /* example GUID from MSDN docs: 6B29FC40-CA47-1067-B31D-00DD010662DA */
    uint8_t bytes[GUIDSIZE] = {0x6B, 0x29, 0xFC, 0x40,
                            0xCA, 0x47,
                            0x10, 0x67,
                            0xB3, 0x1D,
                            0x00, 0xDD, 0x01, 0x06, 0x62, 0xDA};
    uint8_t *buf = bytes;
    bool to_swap = 0;

    uint8_t *head = buf;
    struct guid guid;
    buf = abf2_read_guidp(buf, &guid, to_swap);
    TEST_ASSERT_EQUAL_INT(GUIDSIZE, (buf - head)); /* returned pointer moves to next unread byte */
    if (ENDIAN_LITTLE == get_endian()) {
        TEST_ASSERT_EQUAL_HEX32(0x40FC296B, guid.Data1);
        TEST_ASSERT_EQUAL_HEX16(0x47CA, guid.Data2);
        TEST_ASSERT_EQUAL_HEX16(0x6710, guid.Data3);
    } else {
        TEST_ASSERT_EQUAL_HEX32(0x6B29FC40, guid.Data1);
        TEST_ASSERT_EQUAL_HEX16(0xCA47, guid.Data2);
        TEST_ASSERT_EQUAL_HEX16(0x1067, guid.Data3);
    }
    TEST_ASSERT_EQUAL_HEX8(0xB3, guid.Data4[0]);
    TEST_ASSERT_EQUAL_HEX8(0x1D, guid.Data4[1]);
    TEST_ASSERT_EQUAL_HEX8(0x00, guid.Data4[2]);
    TEST_ASSERT_EQUAL_HEX8(0xDD, guid.Data4[3]);
    TEST_ASSERT_EQUAL_HEX8(0x01, guid.Data4[4]);
    TEST_ASSERT_EQUAL_HEX8(0x06, guid.Data4[5]);
    TEST_ASSERT_EQUAL_HEX8(0x62, guid.Data4[6]);
    TEST_ASSERT_EQUAL_HEX8(0xDA, guid.Data4[7]);
}

void test_abf2_read_fileinfo(void)
{
    uint8_t bytes[ABF2_FILEINFOSIZE] = {
        0x41,0x42,0x46,0x32,0x00,0x00,0x00,0x02,
        0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
        0x43,0x02,0x33,0x01,0x4b,0xe3,0x82,0x03,
        0xc6,0x44,0x01,0x00,0x01,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x08,0x15,0xe7,0x1d,0xf2,0x3b,0xdc,0x41,
        0xb7,0x04,0xa5,0xb8,0x42,0x06,0xa8,0x69,
        0x10,0x00,0x02,0x0a,0x01,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
        0x00,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
        0x80,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,
        0x00,0x01,0x00,0x00,0x04,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x00,
        0x80,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,
        0xcb,0x00,0x00,0x00,0x0e,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x09,0x00,0x00,0x00,
        0x02,0x00,0x00,0x00,0x60,0xf3,0x3d,0x00,
        0x00,0x00,0x00,0x00,0xfd,0x3d,0x00,0x00,
        0x40,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,
        0x01,0x03,0x00,0x00,0x01,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0xfe,0x3d,0x00,0x00,
        0x0c,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    uint8_t *buf = bytes;
    uint8_t *head = buf;

    bool to_swap;
    if (ENDIAN_LITTLE == get_endian()) {
        to_swap = false;
    } else {
        to_swap = true;
    }

    struct abf2_fileinfo finfo;
    buf = abf2_read_fileinfo(buf, &finfo, to_swap);

    TEST_ASSERT_EQUAL_INT(ABF2_FILEINFOSIZE, buf - head);

    TEST_ASSERT_EQUAL_HEX32(ABF2_FILESIGNATURE, finfo.uFileSignature);
    TEST_ASSERT_EQUAL_HEX32(0x02000000, finfo.uFileVersionNumber);
    TEST_ASSERT_EQUAL_UINT32(512, finfo.uFileInfoSize);
    TEST_ASSERT_EQUAL_UINT32(0, finfo.uActualEpisodes);
    TEST_ASSERT_EQUAL_UINT32(20120131, finfo.uFileStartDate);
    TEST_ASSERT_EQUAL_UINT32(58909515, finfo.uFileStartTimeMS);
    TEST_ASSERT_EQUAL_UINT32(83142, finfo.uStopwatchTime);
    TEST_ASSERT_EQUAL_INT16(1, finfo.nFileType);
    TEST_ASSERT_EQUAL_INT16(0, finfo.nDataFormat);
    TEST_ASSERT_EQUAL_INT16(0, finfo.nSimultaneousScan);
    TEST_ASSERT_EQUAL_INT16(0, finfo.nCRCEnable);
    TEST_ASSERT_EQUAL_UINT32(167903248, finfo.uCreatorVersion);
    TEST_ASSERT_EQUAL_UINT32(1, finfo.uCreatorNameIndex);
    TEST_ASSERT_EQUAL_UINT32(0, finfo.uModifierVersion);
    TEST_ASSERT_EQUAL_UINT32(0, finfo.uModifierNameIndex);
    TEST_ASSERT_EQUAL_UINT32(2, finfo.uProtocolPathIndex);
}

void test_abf2_read_protocolinfo(void)
{
    uint8_t bytes[ABF2_PROTOCOLINFOSIZE] = {
        0x05,0x00,0x00,0x00,0x20,0x41,0x00,0x00,
        0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
        0xA0,0x40,0x00,0x00,0x00,0x00,0xC0,0x27,
        0x09,0x00,0x20,0x00,0x00,0x00,0x64,0x00,
        0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0xFD,0xFF,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x86,
        0x01,0x00,0x00,0x00,0x00,0x00,0xE0,0x93,
        0x04,0x00,0x00,0x00,0x00,0x00,0x80,0x3F,
        0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x20,0x41,0x00,0x00,0x20,0x41,0x00,0x80,
        0x00,0x00,0x00,0x80,0x00,0x00,0x01,0x00,
        0x02,0x00,0x01,0x00,0x03,0x00,0x00,0x00,
        0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x40,0x00,0x01,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0xCC,0xCC,
        0xCC,0x3D,0x01,0x00,0xFF,0xFF,0x00,0x00,
        0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,
        0x02,0x00,0x10,0x00,0x08,0x00,0x03,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    uint8_t *buf = bytes;
    uint8_t *head = buf;

    bool to_swap;
    if (ENDIAN_LITTLE == get_endian()) {
        to_swap = false;
    } else {
        to_swap = true;
    }

    struct abf2_protocolinfo pinfo;
    buf = abf2_read_protocolinfo(buf, &pinfo, to_swap);
    TEST_ASSERT_EQUAL_INT(ABF2_PROTOCOLINFOSIZE, buf - head);

    TEST_ASSERT_EQUAL_INT16(5, pinfo.nOperationMode);
    TEST_ASSERT_EQUAL_FLOAT(10.0, pinfo.fADCSequenceInterval);
    TEST_ASSERT_EQUAL_UINT8(0, pinfo.bEnableFileCompression);
    TEST_ASSERT_EQUAL_UINT32(1, pinfo.uFileCompressionRatio);
    TEST_ASSERT_EQUAL_FLOAT(5.0, pinfo.fSynchTimeUnit);
    TEST_ASSERT_EQUAL_FLOAT(0, pinfo.fSecondsPerRun);
    TEST_ASSERT_EQUAL_INT32(600000, pinfo.lNumSamplesPerEpisode);
    TEST_ASSERT_EQUAL_INT32(32, pinfo.lPreTriggerSamples);
    TEST_ASSERT_EQUAL_INT32(100, pinfo.lEpisodesPerRun);
    TEST_ASSERT_EQUAL_INT32(1, pinfo.lRunsPerTrial);
    TEST_ASSERT_EQUAL_INT32(1, pinfo.lNumberOfTrials);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nAveragingMode);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nUndoRunCount);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nFirstEpisodeInRun);
    TEST_ASSERT_EQUAL_FLOAT(0.0, pinfo.fTriggerThreshold);
    TEST_ASSERT_EQUAL_INT16(-3, pinfo.nTriggerSource);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nTriggerAction);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nTriggerPolarity);
    TEST_ASSERT_EQUAL_FLOAT(0.0, pinfo.fScopeOutputInterval);
    TEST_ASSERT_EQUAL_FLOAT(0.0, pinfo.fEpisodeStartToStart);
    TEST_ASSERT_EQUAL_FLOAT(0.0, pinfo.fRunStartToStart);
    TEST_ASSERT_EQUAL_INT32(1, pinfo.lAverageCount);
    TEST_ASSERT_EQUAL_FLOAT(0.0, pinfo.fTrialStartToStart);
    TEST_ASSERT_EQUAL_INT16(1, pinfo.nAutoTriggerStrategy);
    TEST_ASSERT_EQUAL_FLOAT(0.0, pinfo.fFirstRunDelayS);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nChannelStatsStrategy);
    TEST_ASSERT_EQUAL_INT32(100000, pinfo.lSamplesPerTrace);
    TEST_ASSERT_EQUAL_INT32(0, pinfo.lStartDisplayNum);
    TEST_ASSERT_EQUAL_INT32(300000, pinfo.lFinishDisplayNum);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nShowPNRawData);
    TEST_ASSERT_EQUAL_FLOAT(1.0, pinfo.fStatisticsPeriod);
    TEST_ASSERT_EQUAL_INT32(5, pinfo.lStatisticsMeasurements);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nStatisticsSaveStrategy);
    TEST_ASSERT_EQUAL_FLOAT(10.0, pinfo.fADCRange);
    TEST_ASSERT_EQUAL_FLOAT(10.0, pinfo.fDACRange);
    TEST_ASSERT_EQUAL_INT32(32768, pinfo.lADCResolution);
    TEST_ASSERT_EQUAL_INT32(32768, pinfo.lDACResolution);
    TEST_ASSERT_EQUAL_INT16(1, pinfo.nExperimentType);
    TEST_ASSERT_EQUAL_INT16(2, pinfo.nManualInfoStrategy);
    TEST_ASSERT_EQUAL_INT16(1, pinfo.nCommentsEnable);
    TEST_ASSERT_EQUAL_INT32(3, pinfo.lFileCommentIndex);
    TEST_ASSERT_EQUAL_INT16(1, pinfo.nAutoAnalyseEnable);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nSignalType);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nDigitalEnable);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nActiveDACChannel);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nDigitalHolding);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nDigitalInterEpisode);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nDigitalDACChannel);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nDigitalTrainActiveLogic);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nStatsEnable);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nStatisticsClearStrategy);
    TEST_ASSERT_EQUAL_INT16(64, pinfo.nLevelHysteresis);
    TEST_ASSERT_EQUAL_INT32(1, pinfo.lTimeHysteresis);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nAllowExternalTags);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nAverageAlgorithm);
    TEST_ASSERT_EQUAL_FLOAT(0.1, pinfo.fAverageWeighting);
    TEST_ASSERT_EQUAL_INT16(1, pinfo.nUndoPromptStrategy);
    TEST_ASSERT_EQUAL_INT16(-1, pinfo.nTrialTriggerSource);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nStatisticsDisplayStrategy);
    TEST_ASSERT_EQUAL_INT16(2, pinfo.nExternalTagType);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nScopeTriggerOut);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nLTPType);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nAlternateDACOutputState);
    TEST_ASSERT_EQUAL_INT16(0, pinfo.nAlternateDigitalOutputState);
    TEST_ASSERT_EQUAL_FLOAT(0.0, pinfo.fCellID[0]);
    TEST_ASSERT_EQUAL_FLOAT(0.0, pinfo.fCellID[1]);
    TEST_ASSERT_EQUAL_FLOAT(0.0, pinfo.fCellID[2]);
    TEST_ASSERT_EQUAL_INT16(16, pinfo.nDigitizerADCs);
    TEST_ASSERT_EQUAL_INT16(2, pinfo.nDigitizerDACs);
    TEST_ASSERT_EQUAL_INT16(16, pinfo.nDigitizerTotalDigitalOuts);
    TEST_ASSERT_EQUAL_INT16(8, pinfo.nDigitizerSynchDigitalOuts);
    TEST_ASSERT_EQUAL_INT16(3, pinfo.nDigitizerType);
}

void test_abf2_read_mathinfo(void)
{
    uint8_t bytes[ABF2_MATHINFOSIZE];
    uint8_t *buf = bytes;
    uint8_t *head = buf;

    bool to_swap;
    if (ENDIAN_LITTLE == get_endian()) {
        to_swap = false;
    } else {
        to_swap = true;
    }

    struct abf2_mathinfo minfo;
    buf = abf2_read_mathinfo(buf, &minfo, to_swap);
    TEST_ASSERT_EQUAL_INT(ABF2_MATHINFOSIZE, buf - head);
}

void test_abf2_read_adcinfo(void)
{
    uint8_t bytes[ABF2_ADCINFOSIZE];
    uint8_t *buf = bytes;
    uint8_t *head = buf;

    bool to_swap;
    if (ENDIAN_LITTLE == get_endian()) {
        to_swap = false;
    } else {
        to_swap = true;
    }

    struct abf2_adcinfo ainfo;
    buf = abf2_read_adcinfo(buf, &ainfo, to_swap);
    TEST_ASSERT_EQUAL_INT(ABF2_ADCINFOSIZE, buf - head);
}

void test_abf2_read_dacinfo(void)
{
    uint8_t bytes[ABF2_DACINFOSIZE];
    uint8_t *buf = bytes;
    uint8_t *head = buf;

    bool to_swap;
    if (ENDIAN_LITTLE == get_endian()) {
        to_swap = false;
    } else {
        to_swap = true;
    }

    struct abf2_dacinfo dinfo;
    buf = abf2_read_dacinfo(buf, &dinfo, to_swap);
    TEST_ASSERT_EQUAL_INT(ABF2_DACINFOSIZE, buf - head);
}

void test_abf2_read_epochinfoperdacinfo(void)
{
    uint8_t bytes[ABF2_EPOCHINFOPERDACSIZE];
    uint8_t *buf = bytes;
    uint8_t *head = buf;

    bool to_swap;
    if (ENDIAN_LITTLE == get_endian()) {
        to_swap = false;
    } else {
        to_swap = true;
    }

    struct abf2_epochinfoperdac einfo;
    buf = abf2_read_epochinfoperdac(buf, &einfo, to_swap);
    TEST_ASSERT_EQUAL_INT(ABF2_EPOCHINFOPERDACSIZE, buf - head);
}

void test_abf2_read_epochinfo(void)
{
    uint8_t bytes[ABF2_EPOCHINFOSIZE];
    uint8_t *buf = bytes;
    uint8_t *head = buf;

    bool to_swap;
    if (ENDIAN_LITTLE == get_endian()) {
        to_swap = false;
    } else {
        to_swap = true;
    }

    struct abf2_epochinfo einfo;
    buf = abf2_read_epochinfo(buf, &einfo, to_swap);
    TEST_ASSERT_EQUAL_INT(ABF2_EPOCHINFOSIZE, buf - head);
}

void test_abf2_read_statsregioninfo(void)
{
    uint8_t bytes[ABF2_STATSREGIONINFOSIZE];
    uint8_t *buf = bytes;
    uint8_t *head = buf;

    bool to_swap;
    if (ENDIAN_LITTLE == get_endian()) {
        to_swap = false;
    } else {
        to_swap = true;
    }

    struct abf2_statsregioninfo sinfo;
    buf = abf2_read_statsregioninfo(buf, &sinfo, to_swap);
    TEST_ASSERT_EQUAL_INT(ABF2_STATSREGIONINFOSIZE, buf - head);
}

void test_abf2_read_userlistinfo(void)
{
    uint8_t bytes[ABF2_USERLISTINFOSIZE];
    uint8_t *buf = bytes;
    uint8_t *head = buf;

    bool to_swap;
    if (ENDIAN_LITTLE == get_endian()) {
        to_swap = false;
    } else {
        to_swap = true;
    }

    struct abf2_userlistinfo uinfo;
    buf = abf2_read_userlistinfo(buf, &uinfo, to_swap);
    TEST_ASSERT_EQUAL_INT(ABF2_USERLISTINFOSIZE, buf - head);
}
